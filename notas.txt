.\.venv\Scripts\Activate.ps1 ACTIVAR EL ENVIRONMENT
Que contiene carpeta data
logs_backend --> Telemetr√≠a. Base a la que va a consultar search logs_backend
ground truth --> Informaci√≥n que va a usar el judge

Parte de la arquitectura que cumplen 
Definici√≥n del red team runner
Cyber-range representado por assets, roles, subredes en config
Backend A
Seed Controller -- Semilla para la reproducibilidad
Ground truth -- Evaluaci√≥n del blue team y medir m√©tricas

Que hace cada archivo.py
Config.py:
Listamos assets (host, ip, role, criticidad) y usuarios
Tareas: Fuente unica de verdad del inventario del laboratorio
Esto va a alimentar la generacion de lgos, va a servir para la parte del contexto y la logica del blue team( si el activo es hig, acciones m√°s agresivas)
Parte de la arquitectura -- Bloque cyber range virtual

*************************************************************************************
Models.py
Definici√≥n de eventos. Estandarizaci√≥n de la Telemetr√≠a en formato consultable.
Esto va a ser la base para el search logs_backend
Campos:
timestamp, episode_id, seed

event_type (auth/network/process‚Ä¶)

host, user, src_ip, dst_ip

action, outcome, severity

opcionales: process_name, tags
Definici√≥n del ground truth:
    Campos:
        scenario_name, technique_ids (referencial)
        t0, injected_window
        expected_indicators (IPs/hosts/users que deber√≠an aparecer)
Respuesta correcta por episodio. Sirve para que el judge compara decisiones del blue team 
arquitectura: Conecta con el bloque del juez y rigor academico( reproducibilidad y Evaluaci√≥n)
*******************************************************************************************
Scenarios.py
    Lista de escenarios con nombre, tecnica ATTYCK y descripci√≥n 
    Que hace:
        Define tipo de incidente que se inyecta. Parte determinista del red team
        arquitectura: Alineado con MITRE ATTYCK
***************************************************************************************
generate_episodes.py
    N√∫cleo de la fase 1
    
08/02/2026
Desarrollo del mvp de la fase 2 que incluye consulta al backend a, decisi√≥n, acci√≥n simulada y metricas (judge)
Comandos para correr y hacer pruebas completas
python -m src.run_phase2_baseline
python -m src.judge.judge_mttd_mttr
Perfecto ‚Äî aqu√≠ tienes el texto **listo para pegar** siguiendo tu formato, pero ahora **para la Fase 2 (MVP: Backend A + decisiones + acci√≥n simulada + m√©tricas)**.

---

# ‚úÖ 08/02/2026 ‚Äî Fase 2 (MVP m√≠nimo: Backend A + m√©tricas + baseline)

## Activaci√≥n del environment

```powershell
.\.venv\Scripts\Activate.ps1
```

---

## üìÅ ¬øQu√© contiene la carpeta `data/`?

* `data/logs_backend_a/`
  **Telemetr√≠a (JSONL por episodio).**
  Es la ‚Äúbase‚Äù que consulta `search_logs()` en Backend A.

* `data/ground_truth/`
  **Ground truth por episodio (JSON).**
  Lo consume el Judge para calcular MTTD/MTTR.

* `data/decisions/`
  **Decisiones del Blue pipeline (JSONL).**
  Cada fila representa lo que ‚Äúdecidi√≥‚Äù el sistema por episodio (detecci√≥n, evidencia, raz√≥n).

* `data/actions/`
  **Acciones de contenci√≥n simuladas (JSONL).**
  Se registra `block_ip` con `action_time` (timestamp del mundo simulado).

* `data/results/`
  **Resultados finales en CSV** (por ejemplo `results_phase2.csv`) con MTTD/MTTR.

---

## üß± Parte de la arquitectura que cumple esta Fase 2

‚úÖ **Backend A (JSON local)**

* Ya existe `search_logs()` para consultar la telemetr√≠a por filtros/rango/limit/top-k.

‚úÖ **Cyber-range representado por Assets (config)**

* `get_asset_context()` devuelve contexto del activo para enriquecer decisiones.

‚úÖ **Acciones defensivas simuladas**

* `block_ip()` no bloquea realmente: **registra** una acci√≥n para auditor√≠a y m√©tricas.

‚úÖ **Judge (m√©tricas)**

* Calcula **MTTD/MTTR** comparando ground truth vs. decisiones/acciones.

‚úÖ **Runner baseline**

* Ejecuta episodios en batch y genera decisiones + acciones simuladas.

> Importante: en este MVP **todav√≠a no hay Blue AI Agent**.
> El ‚ÄúBlue‚Äù actual es un baseline heur√≠stico que valida el pipeline end-to-end. El agente IA entra en el siguiente paso de Fase 2/3.

---

# üß© ¬øQu√© hace cada archivo de Fase 2?

## 1) `src/backend_a/search_logs.py`

**Funci√≥n principal:** `search_logs()`

### Qu√© hace

* Lee archivos `episode_XXX.jsonl`
* Aplica:

  * filtro por `episode_id`
  * rango de tiempo `start/end`
  * filtros por campos (`host/user/src_ip/event_type/action/tags‚Ä¶`)
  * `limit`
  * agregaci√≥n simple (`count`, `top_k`)

### Para qu√© sirve

* Es el equivalente ‚ÄúSIEM-lite‚Äù para que el Blue Team investigue con queries.

### Resultado validado

Ejemplo: filtr√≥ correctamente eventos `auth_fail` y devolvi√≥:

* `matched: 165`
* `returned: 5` (por `limit=5`)
* con tags y severidad coherentes (`medium`, `auth_fail`, `service_account`, etc.)

---

## 2) `src/tools/asset_context.py`

**Funci√≥n principal:** `get_asset_context(host_or_ip)`

### Qu√© hace

* Busca un asset por `host` o `ip` usando `src/core/config.py`
* Devuelve contexto:

  * host, ip, role, criticality
  * (opcional) metadata extra definida expl√≠citamente en config (no hardcode)

### Para qu√© sirve

* Enriquecimiento: el Blue pipeline decide distinto si el activo es `high` (ej: DB).

### Resultado validado

* `db-01` ‚Üí encontrado, `criticality=high`
* `10.0.10.21` ‚Üí encontrado, `ws-01`
* `no-existe` ‚Üí `asset_not_found`

---

## 3) `src/tools/enforcement.py`

**Funci√≥n principal:** `block_ip(ip, duration, action_time=...)`

### Qu√© hace

* Simula contenci√≥n: **no bloquea en firewall real**
* Registra acci√≥n en `data/actions/enforcement_actions.jsonl`
* Usa `action_time` (tiempo simulado del episodio) para consistencia temporal

### Para qu√© sirve

* Auditor√≠a y m√©tricas: el Judge usa el timestamp del bloqueo para MTTR.

‚úÖ Fix aplicado: antes sal√≠a MTTR negativo porque se guardaba ‚Äúhora real‚Äù, ahora usa ‚Äúhora simulada‚Äù.

---

## 4) `src/blue/decision_log.py`

**Funci√≥n principal:** `append_decision(...)`

### Qu√© hace

* Guarda una decisi√≥n por episodio en `data/decisions/decisions.jsonl`:

  * `episode_id`
  * `t_detect`
  * `decision` (`block_ip` / `no_block` / `escalate`)
  * `reason`
  * `evidence` (evento que motiv√≥ la decisi√≥n + contexto del asset)

### Para qu√© sirve

* Trazabilidad y reproducci√≥n: explica por qu√© se tom√≥ cada acci√≥n.

---

## 5) `src/judge/judge_mttd_mttr.py`

**Funci√≥n principal:** `judge_mttd_mttr()`

### Qu√© hace

* Lee:

  * `data/ground_truth/*.json` ‚Üí `inj_start`
  * `data/decisions/decisions.jsonl` ‚Üí `t_detect`
  * `data/actions/enforcement_actions.jsonl` ‚Üí `t_block`
* Calcula:

  * **MTTD = t_detect - inj_start**
  * **MTTR = t_block - inj_start**
* Escribe CSV final: `data/results/results_phase2.csv`

### Para qu√© sirve

* Entrega m√©tricas cuantitativas reproducibles (base acad√©mica del experimento).

---

## 6) `src/run_phase_2_baseline.py`

**Runner baseline (sin IA todav√≠a)**

### Qu√© hace

* Lista episodios disponibles en `data/logs_backend_a`
* Encuentra se√±al sospechosa por tags (ej. `suspicious`, `lateral_like`, etc.)
* Enrich con `get_asset_context`
* Decide con heur√≠stica:

  * si `severity in (medium/high)` y **no allowlisted** ‚Üí `block_ip`
* Registra:

  * decisi√≥n (decision_log)
  * acci√≥n (enforcement)
* Ejecuta Judge y genera CSV final

### Resultado obtenido

Inicialmente MTTR sal√≠a negativo por timestamp real ‚Üí se corrigi√≥ usando `action_time=t_detect+30s`.

---

# ‚ñ∂Ô∏è Comandos para ejecutar pruebas completas

```powershell
python -m src.run_phase_2_baseline
python -m src.judge.judge_mttd_mttr
```

---

# üìä Resultados obtenidos (ejemplo)

En `data/results/results_phase2.csv`:

```csv
episode_id,decision,inj_start,t_detect,t_block,MTTD_seconds,MTTR_seconds
1,block_ip,2026-02-19T10:11:00Z,2026-02-19T10:11:00Z,2026-02-19T10:11:30Z,0.0,30.0
```

Interpretaci√≥n:

* MTTD = 0s ‚Üí detecci√≥n inmediata (baseline encontr√≥ el evento exacto)
* MTTR = 30s ‚Üí respuesta simulada 30s despu√©s

---

# ‚úÖ Estado final de Fase 2 (MVP m√≠nimo)

**Listo y funcionando:**

* Backend A consultable (`search_logs`)
* Enrichment (`get_asset_context`)
* Acci√≥n simulada (`block_ip`)
* Decision logging
* Judge MTTD/MTTR
* Runner baseline end-to-end

**Siguiente paso (ya con IA):**

* Implementar **Blue Team AI Agent** (LangGraph) usando:    

  * `search_logs`
  * `get_asset_context`
  * `retrieve_memory` (FAISS)
  * `decide` + gating/HITL (simulado)
  * `block_ip`

---

Si quieres, el pr√≥ximo mensaje lo hacemos as√≠: **‚ÄúFase 2.5: introducir FAISS (memoria) + retrieve_memory()‚Äù** para que luego el Blue Agent IA solo ‚Äúconsuma‚Äù esa interfaz.

